<!doctype html>
<html>
<head>
	<meta http-equiv="charset" content="text/html; charset=utf-8">
	<title></title>
	<style>
		{{ getTestPageCSS() }}

		#controls tr td {
			padding: 0.5em 0 0.5em 0;
		}
	</style>
</head>
<body>
<!-- note: this file is mostly a copy/paste of chatapp.html -->

<div id="doc">
This page supports options ?mode=http, ?mode=flash, ?useSub=0, ?useSub=1
(which can be combined).  Note: when using subdomains, you'll see fewer log
messages because log messages in the iframes are not sent to this parent window.
</div>

<table id="controls">
<tr>
	<td>Reconnect:</td>
	<td>
		<input type="submit" value="Reset" onclick="rtsgame.resetStream('because user clicked button');return false">
		<input type="submit" value="Reset and connect new stream" onclick="rtsgame.reconnectStream();return false">
	</td>
</tr>
<tr>
<td>
	Send text:
</td>
<td>
	<input type="text" name="textinput" id="textinput">
	<input type="submit" value="Send" onclick="rtsgame.sendText(byId('textinput').value);return false">
</td>
</tr>
</table>

<script>
	window.CSRF_TOKEN = {{ dumps(token) }};
	document.domain = {{ dumps(domain) }};
	var __XDRFrame_loaded = function(id) {
		__XDRFrame_loaded.done.push(id);
	};
	__XDRFrame_loaded.done = [];
	// We expect location.port to be an empty string if no :port is in
	// the URL.  If there is an explicit port, we need to load the iframe
	// with that port, even if it's the default port (80 or 443), because
	// a mismatch of "explicit port" and "implicit port" may prevent
	// cross-subdomain interaction from working in some browsers.
	__XDRFrame_loaded.portString = location.port ? ':' + location.port : "";
	__XDRFrame_loaded.url1 = location.protocol + '//{{ sub1 }}.{{ domain }}' +
		__XDRFrame_loaded.portString + '/';
	__XDRFrame_loaded.url2 = location.protocol + '//{{ sub2 }}.{{ domain }}' +
		__XDRFrame_loaded.portString + '/';
	document.write(
		'<iframe width=16 height=16 src="' + __XDRFrame_loaded.url1 +
			'xdrframe/?id=1" id="xdrframe-1"></iframe>' +
		'<iframe width=16 height=16 src="' + __XDRFrame_loaded.url2 +
			'xdrframe/?id=2" id="xdrframe-2"></iframe>');
</script>

<div id="FlashConnectorSwf"></div>

<div id="log"></div>

<script src="/JSPATH/closure/goog/base.js"></script>
<script src="/JSPATH/nongoog_deps.js"></script>
<script>
goog.provide('rtsgame');

goog.require('cw.autoTitle');
goog.require('goog.debug.DivConsole');
goog.require('goog.debug.Logger');
goog.require('goog.debug.LogManager');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.Uri');
goog.require('cw.eventual');
goog.require('cw.string');
goog.require('cw.net.Stream');
goog.require('cw.net.IMinervaProtocol');
goog.require('cw.net.demo.getEndpoint');
goog.require('cw.net.demo.makeCredentialsData');
goog.require('cw.repr');
goog.require('cw.string');
</script>

<script>
goog.debug.LogManager.getRoot().setLevel(goog.debug.Logger.Level.ALL);

var logDiv = document.getElementById('log');
var divConsole = new goog.debug.DivConsole(logDiv);
divConsole.setCapturing(true);

rtsgame.logger = goog.debug.Logger.getLogger('rtsgame.logger');
rtsgame.logger.info('Logger works.');


window.onerror = function(msg, url, lineNumber) {
	rtsgame.logger.severe('window.onerror: message: ' + cw.repr.repr(msg) +
		'\nURL: ' + url + '\nLine Number: ' + lineNumber)
};


function byId(o) {
	return document.getElementById(o);
}

/**
 * @implements {cw.net.IMinervaProtocol}
 * @constructor
 */
rtsgame.ChatProtocol = function() {

};

rtsgame.ChatProtocol.prototype.streamStarted = function(stream) {
	this.stream_ = stream;
	rtsgame.logger.info('streamStarted');
	this.stream_.sendStrings(['begin_chat']);
};

rtsgame.ChatProtocol.prototype.streamReset = function(reasonString, applicationLevel) {
	rtsgame.logger.info(
		'streamReset: reasonString=' + cw.repr.repr(reasonString) +
		', applicationLevel=' + applicationLevel);
};

rtsgame.ChatProtocol.prototype.handleString_ = function(s) {
	function fail() {
		rtsgame.logger.severe('Could not handle string: ' + cw.repr.repr(s));
	}

	var splitted = cw.string.split(s, '|', 2);
	if(splitted.length != 3) {
		return fail();
	}
	var type = splitted[0];
	var uaId = splitted[1];
	var text = splitted[2];
	if(type != "TEXT") {
		return fail();
	}

	// TODO: add timestamp
	rtsgame.logger.info(cw.string.format('<{0}> {1}', uaId, text));
};

rtsgame.ChatProtocol.prototype.stringsReceived = function(strings) {
	for(var i=0; i < strings.length; i++) {
		var s = strings[i];
		this.handleString_(s);
	}
};

/**
 * @param {string} reason
 */
rtsgame.ChatProtocol.prototype.reset = function(reason) {
	rtsgame.logger.info('resetting with reason: ' + reason);
	this.stream_.reset(reason);
};

rtsgame.ChatProtocol.prototype.sendText = function(text) {
	rtsgame.logger.info('sendText: ' + text);
	this.stream_.sendStrings(["broadcast:" + text]);
};


/**
 * @type {?rtsgame.ChatProtocol}
 */
rtsgame.lastProto = null;


rtsgame.callQueue = new cw.eventual.CallQueue(goog.global['window']);


rtsgame.idleFired = function() {
	rtsgame.resetStream("idle timeout fired");
	rtsgame.lastProto = null;
};


rtsgame.idleTimeout = null;


rtsgame.activityDetected = function(ev) {
	if(rtsgame.idleTimeout != null) {
		rtsgame.callQueue.clock.clearTimeout(rtsgame.idleTimeout);
	}

	// Only need a timeout if we have an active Stream
	if(rtsgame.lastProto) {
		rtsgame.idleTimeout = rtsgame.callQueue.clock.setTimeout(
			rtsgame.idleFired, 600 * 1000);
	}
};


/**
 * @type {!Array.<!goog.events.EventType>}
 */
rtsgame.activityEvents = [
	goog.events.EventType.CLICK,
	goog.events.EventType.FOCUS,
	goog.events.EventType.KEYDOWN,
	goog.events.EventType.KEYPRESS];
rtsgame.clickListen = goog.events.listen(
	goog.global, rtsgame.activityEvents, rtsgame.activityDetected, true);


rtsgame.startStream = function() {
	rtsgame.lastProto = new rtsgame.ChatProtocol();
	rtsgame.activityDetected();
	var endpointD = cw.net.demo.getEndpoint(rtsgame.callQueue);
	endpointD.addCallback(function(endpoint) {
		var stream = new cw.net.Stream(
			rtsgame.callQueue, rtsgame.lastProto, endpoint, cw.net.demo.makeCredentialsData);
		stream.start();
	});
};


/**
 * @param {string} reason
 */
rtsgame.resetStream = function(reason) {
	rtsgame.lastProto.reset(reason);
};


rtsgame.reconnectStream = function() {
	if(rtsgame.lastProto) {
		rtsgame.lastProto.reset('because user clicked reconnect button');
	}
	rtsgame.startStream();
};


rtsgame.sendText = function(text) {
	rtsgame.lastProto.sendText(text);
};


rtsgame.startStream();

</script>

</body>
</html>
